# Команды Git
## Основные команды
Всего несколько команд нужно для базового варианта использования Git для ведения истории изменений.
### **git add**
Команда **git add** добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита. По умолчанию **git commit** использует лишь этот индекс, так что вы можете использовать **git add** для сборки слепка вашего следующего коммита.
Это одна из ключевых команд Git, мы упоминали о ней десятки раз на страницах книги. Ниже перечислены наиболее интересные варианты использования этой команды.
* Знакомство с этой командой происходит в разделе [Отслеживание новых файлов главы 2](https://git-scm.com/book/ru/v2/Основы-Git-Запись-изменений-в-репозиторий#r_tracking_files).
* О том как использовать **git add** для разрешения конфликтов слияния написано в разделе [Основные конфликты слияния главы 3](https://git-scm.com/book/ru/v2/Ветвление-в-Git-Основы-ветвления-и-слияния#r_basic_merge_conflicts).
* В разделе [Интерактивное индексирование главы 7](https://git-scm.com/book/ru/v2/Инструменты-Git-Интерактивное-индексирование#r_interactive_staging) показано как использовать **git add** для добавления в индекс лишь отдельных частей изменённого файла.
* В разделе [Деревья](https://git-scm.com/book/ru/v2/Git-изнутри-Объекты-Git#r_tree_objects) показано как эта команда работает на низком уровне, чтобы вы понимали, что происходит за кулисами.
### **git status**
Команда **git status** показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

Мы познакомили вас с этой командой в разделе [Определение состояния файлов главы 2](https://git-scm.com/book/ru/v2/Основы-Git-Запись-изменений-в-репозиторий#r_checking_status), разобрали стандартный и упрощённый формат вывода. И хотя мы использовали **git status** повсеместно в этой книге, практически все варианты использования покрыты в указанной главе.

### **git diff**
Команда **git diff** используется для вычисления разницы между любыми двумя Git деревьями. 
Это может быть:
1. разница между вашей рабочей копией и индексом (собственно *git diff*), 
2. разница между индексом и последним коммитом (*git diff --staged*), 
3. разница между любыми двумя коммитами (*git diff master branchB*).

Мы познакомили вас с основами этой команды в разделе [Просмотр индексированных и неиндексированных изменений главы 2](https://git-scm.com/book/ru/v2/Основы-Git-Запись-изменений-в-репозиторий#r_git_diff_staged), где показали как посмотреть какие изменения уже добавлены в индекс, а какие — ещё нет.

О том как использовать эту команду для проверки на проблемы с пробелами с помощью аргумента *--check* можно почитать в разделе [Правила создания коммитов главы 5](https://git-scm.com/book/ru/v2/Распределенный-Git-Участие-в-проекте#r_commit_guidelines).

Мы показали вам как эффективно сравнивать ветки используя синтаксис *git diff A…B* в разделе [Определение применяемых изменений главы 5](https://git-scm.com/book/ru/v2/Распределенный-Git-Сопровождение-проекта#r_what_is_introduced).

В разделе [Продвинутое слияние главы 7](https://git-scm.com/book/ru/v2/Инструменты-Git-Продвинутое-слияние#r_advanced_merging) показано использование опции *-w* для скрытия различий в пробельных символах, а также рассказано как сравнивать конфликтующие изменения с опциями *--theirs*, *--ours* и *--base*.

Использование этой команды с опцией *--submodule* для сравнения изменений в подмодулях показано в разделе [Начало работы с подмодулями главы 7](https://git-scm.com/book/ru/v2/Инструменты-Git-Подмодули#r_starting_submodules).

# 2.5 Основы Git - Работа с удалёнными репозиториями

## Просмотр удалённых репозиториев

### **git remote**
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду **git remote**. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум *origin* — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование. Вы можете также указать ключ *-v*, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию.

### Получение изменений из удалённого репозитория — **Fetch** и **Pull**
Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:

> $ git fetch [remote-name]

Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда *clone* автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, **git fetch origin** извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью *fetch*). Важно отметить, что команда **git fetch** забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Выполнение **git pull**, как правило, извлекает (*fetch*) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

## Отправка изменений в удаленный репозиторий (Push)
Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: 

**git push < remote-name> < branch-name>** 

Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

> $ git push origin master

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду *push*. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду *push*, а после него выполнить команду *push* попытаетесь вы, то ваш *push* точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push. Обратитесь к главе [Ветвление в Git](https://git-scm.com/book/ru/v2/Ветвление-в-Git-О-ветвлении-в-двух-словах#ch03-git-branching) для более подробного описания, как отправлять изменения на удалённый сервер.